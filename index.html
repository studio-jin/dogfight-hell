
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Dogfight Hell</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="pixi.js"></script>
</head>
<body style="background-color: #251c3e; margin: 0; padding: 0; overflow: hidden;">
    <!-- SPIRIT OF SCRAPPINESS -->
    <script type="module">
        // Intro
        const intro = [
            "┌─────────────────────────────────────────────┐",
            "│ Dogfight Hell v0.0.1                 SN-001 │",
            "│                                             │",
            "│ by Studio Jin                               │",
            "│                                             │",
            "│ https://github.com/studio-jin/dogfight-hell │",
            "└─────────────────────────────────────────────┘"
        ];

        // Initialize the game
        const app = new PIXI.Application();
        await app.init({ 
            width: window.innerWidth,
            height: window.innerHeight,
            resizeTo: window,
            // backgroundColor: 0xf0f0f0
            backgroundColor: 0x251c3e
        });
        console.log(intro.join('\n'));

        // Load Assets
        await PIXI.Assets.load([
            'fighter.png',
            'crosshair.png',
            'bullet.png',
        ]);

        // World
        const world = { width: 600, height: 400 };

        // Zoom
        let zoom = 1;

        // Sprite Scale
        PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;
        const spriteScale = 3;


        // Camera
        const viewport = { width: window.innerWidth, height: window.innerHeight };
        const setupDebugBound = () => {
            let debugBound = new PIXI.Graphics()
                .rect(0, 0, world.width, world.height)
                .stroke({ width: 1, color: 'white' });
            app.stage.addChild(debugBound);
            app.stage.position.set(100.0, 100.0);
        }
        const debugBound = setupDebugBound()
        
        // Resize Handler
        const onResize = () => {
            viewport.width = window.innerWidth;
            viewport.height = window.innerHeight;
            // Center the world
            app.stage.position.set(
                Math.floor((viewport.width - world.width * zoom) / 2),
                Math.floor((viewport.height - world.height * zoom) / 2)
            );
            app.stage.scale.set(zoom);
        }
        window.addEventListener('resize', onResize);
        onResize();

        // Crosshair
        const createCrosshair = () => {
            const crosshair = PIXI.Sprite.from('crosshair.png');
            crosshair.anchor.set(0.5);
            crosshair.scale.set(spriteScale);
            crosshair.position.set(world.width / 2, world.height / 2);
            crosshair.texture.source.scaleMode = 'nearest';
            app.stage.addChild(crosshair);
            return crosshair;
        }
        const crosshair = createCrosshair();

        // Fighter
        const createFighter = () => {
            const fighter = PIXI.Sprite.from('fighter.png');
            fighter.anchor.set(0.5);
            fighter.scale.set(spriteScale);
            fighter.position.set(world.width / 2, world.height / 2);
            fighter.texture.source.scaleMode = 'nearest';
            app.stage.addChild(fighter);
            return fighter;
        }

        // Start The Game
        const fighter = createFighter();
        document.body.appendChild(app.canvas);
        let elapsed = 0.0;
        
        // Update Time
        const updateElapsedTime = (ticker) => {
            elapsed += ticker.deltaTime;
        }

        // Update Crosshair
        const updateCrosshair = (ticker) => {
            crosshair.x = Math.round((pointer.x - app.stage.x) / zoom);
            crosshair.y = Math.round((pointer.y - app.stage.y) / zoom);
        }
        
        // Mouse Input
        let pointer = { x: 0, y: 0 };
        const onMouseMove = (event) => {
            if (document.pointerLockElement === document.body) {
                pointer.x += event.movementX;
                pointer.y += event.movementY;
                // Clamp the pointer
                pointer.x = Math.max(0, Math.min(viewport.width, pointer.x));
                pointer.y = Math.max(0, Math.min(viewport.height, pointer.y));
            } else {
                pointer.x = event.clientX;
                pointer.y = event.clientY;
            }
        }
        document.addEventListener('mousemove', onMouseMove);
        
        // Pointer Lock
        document.body.requestPointerLock = 
            document.body.requestPointerLock || 
            document.body.mozRequestPointerLock || 
            document.body.webkitRequestPointerLock;
        document.body.addEventListener('click', () => {
            document.body.requestPointerLock();
        });
        
        // Keyboard Input
        const controls = {
            up: {
                keys: ['w', 'ArrowUp'],
                downAt: 0,
                upAt: 0
            },
            down: {
                keys: ['s', 'ArrowDown'],
                downAt: 0,
                upAt: 0
            },
            left: {
                keys: ['a', 'ArrowLeft'],
                downAt: 0,
                upAt: 0
            },
            right: {
                keys: ['d', 'ArrowRight'],
                downAt: 0,
                upAt: 0
            },
            shoot: {
                keys: [' '],
                downAt: 0,
                upAt: 0
            }
        };
        const onKeyDown = (event) => {
            for (const control of Object.values(controls)) {
                if (control.keys.includes(event.key) && control.downAt <= control.upAt) {
                    control.downAt = performance.now();
                }
            }
        }
        const onKeyUp = (event) => {
            for (const control of Object.values(controls)) {
                if (control.keys.includes(event.key) && control.downAt > control.upAt) {
                    control.upAt = performance.now();
                }
            }
        }
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Mouse Press to shoot
        const onMouseDown = (event) => {
            if (controls.shoot.downAt <= controls.shoot.upAt) {
                controls.shoot.downAt = performance.now();
            }
        }
        const onMouseUp = (event) => {
            if (controls.shoot.downAt > controls.shoot.upAt) {
                controls.shoot.upAt = performance.now();
            }
        }
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);

        // Bullets
        const bulletSpeed = 8;
        const recoilAmount = 10;
        const maxBulletCounts = 1000;
        const bullets = Array(maxBulletCounts).fill(null);
        let bulletIndex = 0;
        const createBullet = (i) => {
            const bullet = PIXI.Sprite.from('bullet.png');
            bullet.anchor.set(0.5);
            bullet.scale.set(spriteScale);
            bullet.position.set(-10000, -10000);
            bullet.texture.source.scaleMode = 'nearest';
            bullet.velocity = { x: 0, y: 0 };
            app.stage.addChild(bullet);
            return bullet;
        }
        for (let i = 0; i < maxBulletCounts; i++) {
            bullets[i] = createBullet();
        }
        const shoot = (x, y, angle) => {
            const bullet = bullets[bulletIndex];
            bullet.x = x;
            bullet.y = y;
            // bullet.rotation = angle;
            bullet.velocity.x = Math.cos(angle) * 8;
            bullet.velocity.y = Math.sin(angle) * 8;
            bulletIndex = (bulletIndex + 1) % maxBulletCounts;
        }
        const updateBullets = (ticker) => {
            for (const bullet of bullets) {
                bullet.x += bullet.velocity.x * ticker.deltaTime;
                bullet.y += bullet.velocity.y * ticker.deltaTime;
            }
        }

        // Update Fighter
        const fighterVelocity = { x: 0, y: 0 };
        const efficacy = 4;
        let shootCooldown = 0; 
        const applyDrag = (velocity) => {
            const drag = 0.40;
            const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            if (magnitude > 0) {
                velocity.x -= velocity.x * drag;
                velocity.y -= velocity.y * drag;
            }
        }
        const updateFighter = (ticker) => {
            // Align the fighter to the crosshair
            const dx = crosshair.x - fighter.x;
            const dy = crosshair.y - fighter.y;
            const angle = Math.atan2(dy, dx);
            const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
            fighter.rotation = snappedAngle + Math.PI / 2;

            
            // Shoot
            if (controls.shoot.downAt > controls.shoot.upAt) {
                if (shootCooldown <= 0) {
                    shootCooldown = recoilAmount;
                    shoot(fighter.x, fighter.y, angle);
                }
                shootCooldown -= ticker.deltaTime;
            }

            // Move the fighter
            let throttle = { x: 0, y: 0 };
            if (controls.up.downAt > controls.up.upAt) {
                throttle.y -= 1;
            }
            if (controls.down.downAt > controls.down.upAt) {
                throttle.y += 1;
            }
            if (controls.left.downAt > controls.left.upAt) {
                throttle.x -= 1;
            }
            if (controls.right.downAt > controls.right.upAt) {
                throttle.x += 1;
            }
            // Normalize the throttle
            const magnitude = Math.sqrt(throttle.x * throttle.x + throttle.y * throttle.y);
            if (magnitude > 0) {
                throttle.x /= magnitude;
                throttle.y /= magnitude;
            }
            fighterVelocity.x += throttle.x * efficacy;
            fighterVelocity.y += throttle.y * efficacy;
            applyDrag(fighterVelocity);
            fighter.x += fighterVelocity.x * ticker.deltaTime;
            fighter.y += fighterVelocity.y * ticker.deltaTime;

            // Clamp the fighter
            fighter.x = Math.max(fighter.width / 2, Math.min(world.width - fighter.width / 2, fighter.x));
            fighter.y = Math.max(fighter.height / 2, Math.min(world.height - fighter.height / 2, fighter.y));
        }

        // Game Loop
        const gameLoop = (ticker) => {
            updateElapsedTime(ticker);
            updateCrosshair(ticker);
            updateFighter(ticker);
            updateBullets(ticker);
        }
        
        app.ticker.add(gameLoop)
    </script>
</body>
</html>